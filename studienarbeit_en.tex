%! TEX program = pdflatex
\documentclass[arbeit=studie,oneside,BCOR=12mm]{ArbeitRST}
\usepackage{amsmath} 
\hypersetup{
  unicode=false,          % non-Latin characters in Acrobat’s bookmarks
  pdftoolbar=true,        % show Acrobat’s toolbar?
  pdfmenubar=true,        % show Acrobat’s menu?
  pdffitwindow=false,     % window fit to page when opened
  pdfstartview={FitH},    % fits the width of the page to the window
  pdftitle={Verbessung der Spurerkennung und -verfolgung autonomer Modellfahrzeuge}, % title
  pdfauthor={James Vero Asghar},     % author
  pdfsubject={Subject},   % subject of the document
  pdfcreator={James Vero Asghar},   % creator of the document
  pdfproducer={Producer}, % producer of the document
  pdfkeywords={Stanley controller} {sliding window method} {model cars}, % list of keywords
  pdfnewwindow=true,      % links in new window
  colorlinks=true,        % false: boxed links; true: colored links
  linkcolor=blue,         % color of internal links (change box color with linkbordercolor)
  citecolor=green,        % color of links to bibliography
  filecolor=magenta,      % color of file links
  urlcolor=cyan           % color oPf external links
  }
\setlength{\parindent}{0ex}
\setlength{\parskip}{2ex}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Entfernt die farbigen Markierungen - bitte Druckversion mit dieser Option kompilieren
%\hypersetup{hidelinks}

\begin{document}

% Titelseite
% ==========

% Name des Verfassers
\author{James Vero Asghar}

% Geburtsort
\geburtsort{Austin, Texas, Vereignete Staaten}

% Geburtsdatum
\geburtsdatum{3. Dezember 1997}

% Titel der Arbeit
\title{Verbesserung der Spurerkennung und -verfolgung autonomer Modellfahrzeuge}

% Untertitel
\subtitle{}

% Angabe der Betreuer
\betreuer{Dr.-Ing. Carsten Knoll}
\betreuer{M.Sc. Paul Auerbach}

% Datum der Einreichung
\date{2. Februar 2222}


% Zunächst für das Vorgeplänkel römische Seitenzahlen und einfacher Seitenstil
% ============================================================================
\pagenumbering{Roman}
\pagestyle{plain}


% Titelseite erstellen
\maketitle


% Selbstständigkeitserklärung
% ===========================

% Selbstständigkeitserklärung erstellen
\selbststaendigkeitserklaerung


% Kurzfassung / Abstract
% ======================
\kurzfassung{An dieser Stelle fügen Sie bitte eine deutsche Kurzfassung ein.}
{At the Connected Robotics Lab (CoRoLa) research group at the Barkhausen
Institut, a demonstration using remote controlled 2 axis vehicles was
developed. The demonstration is currently in use in order to model
communications between vehicles similar to an Internet of Things (IoT) network.

In order to better model the complexities of a real world system a nonlinear
control algorithm was introduced to the system in order to more accurately
control the vehicles. The Stanley Controller is a nonlinear controller
developed for use with the lateral control of 2 axis vehicles in mind. As input
to the controller, a fisheye camera was used to create images of road. These
images were then digitally processed to find the yellow line for the vehicles
to follow.}


% Inhaltsverzeichnis
% ==================
\tableofcontents

\chapter{Einleitung}

The Connected Robotics Lab (CoRoLa) research group at the Barkhausen Institut
has developed a demonstration that uses remote-controlled two-axle vehicles to
model communications between remote-controlled vehicles in an Internet of
Things (IoT) network.

The autonomous control of each remote-controlled vehicle on the track is
accomplished through a centralized computer. The track, as depicted in FIGURE,
comprises a black floor and a yellow lane line. The vehicle utilizes a fisheye
camera for detecting the lane line, which is then steered using a PID
controller. An image processing pipeline on the computer is utilized for
processing each new image from the vehicle's camera, at a frequency of 50 Hz.
The pipeline extracts all yellow pixels from the image and considers the
densest grouping to be the lane line. The distance between the $x$-coordinate
of this grouping and the centerline of the image is provided as the input to
the PID controller, which guides the vehicle onto the lane.

However, due to limitations in the current vehicle controller, such as low
forward velocity and lack of robustness, it has been proposed to implement a
new controller. To achieve this objective, the proposed solution includes the
expansion of the image processing pipeline and replacing the PID controller
with the Stanley controller. 

\iffalse
At the Connected Robotics Lab (CoRoLa) research group at the Barkhausen
Institut, a demonstration using remote controlled two axle vehicles was
developed. The demonstration is currently in use in order to model
communications between vehicles similar to an Internet of Things (IoT) network.

Due to issues regarding low forward velocity and robustness of the current
vehicle controller, it was proposed to implement a new 

In order to achieve the goals stated above, creation of an image processing
pipeline and implementation of the Stanley controller are proposed.
\fi

\iffalse
Each remote-controlled vehicle is autonomously controlled, using a central
computer, to travel around a track. The track, seen in FIGURE, is composed of a
black floor and a yellow lane line. 

A vehicle is equipped with a fisheye camera to detect the lane line and
steered using a PID controller. The computer has an image processing pipeline,
which processes a new image from the vehicle's camera at a rate of 50 Hz. The
computer extracts all yellow pixels from the image and considers the densest
grouping to be the lane line. The input to the PID controller is then the
distance from the $x$-coordinate of this grouping to the centerline of the
image. These components work together to steer the vehicle onto lane.
\fi

\chapter{Regelalgorithmus}

\section{Stanley-Regler}
\iffalse
The Stanley controller is a non-linear control algorithm developed in 2005 by
Stanford University. It was developed in order to control a 2 axle vehicle
using only the heading and the cross track error from the path to be followed.
It was proven to be asymptotically global stable for the kinematic model of a
two axle vehicle .However in for the duration of this thesis the the model used
is not the kinematic model of a 2 axle vehicle instead a model that also
accounts for the dynamics of the steering angle.

The stanley controller is a path following controller as opposed to a
trajectory following algorithm. The stanley controller is designed as a lateral
controller,  so that the vehicle stays on the path, but has no bearing on the
speed at which it will follow the path. The positives of this approach allow
for a flexible choice of the speed of the vehicle, which barring dynamic
effects, allows for a engineer to choose any speed necessary for their
application.

The stanley controller is represented by the following equation: $$u = \theta_d
- \theta + \arctan\left(\frac{ke_{fa}}{v}\right),$$ where $u$ is the controller
output, $\theta$ is the current heading of the vehicle, $\theta_d$ is the
heading of the path, $k$ is a scaling factor, $v$ is the velocity of the
vehicle, and $e_{fa}$ is the cross track error from the midpoint of the
vehicle’s front axle to the path. 

The stanley controller is composed of two components:  a component handling the
offset of the vehicle from the path and a component handling the derivative of
the offset (difference in heading).  The first component, represented by
$\arctan(\frac{ke_{fa}}{v})$,  drives the steering angle to turn more towards
the path, the farther away the car currently is. The second component,
represented by $\theta_d - \theta$, controls the steering angle to stay
parallel with the path to be followed. Working together, the two components
steer the vehicle on to the path to be followed.

\fi

The Stanley controller is a non-linear control algorithm that was developed in
2005 by Stanford University with the purpose of controlling a two-axle vehicle
using only the heading and the cross track error from the path to be followed.
The algorithm has been proven to be asymptotically globally stable for the
kinematic model of a two-axle vehicle. (STANFORD)

The Stanley controller is a path following controller instead of a trajectory
following controller. As a lateral controller, it is designed to keep the
vehicle on the path but has no impact on the forward speed. This approach
allows for a flexible choice of the vehicle speed, which can be selected as
required for a given application, subject to dynamic effects. The Stanley
controller is represented mathematically by the following equation: 
\begin{equation} 
    u = \theta - \theta_d + \arctan\left(\frac{ke_{fa}}{v}\right), 
    \label{eq:Stanley-Regler} 
\end{equation}
where $u$ represents the controller output, $\theta$ is the current heading of
the vehicle, $\theta_d$ is the heading of the path, $k$ is a scaling factor,
$v$ is the velocity of the vehicle, and $e_{fa}$ is the cross track error from
the midpoint of the vehicle's front axle to the path.

The Stanley controller consists of two components: a component that handles the
offset of the vehicle from the path and a component handles the difference in
vehicle heading and path heading. The first component is represented by
$\arctan(\frac{ke_{fa}}{v})$ and drives the steering angle to turn towards the
path as the car gets farther away from it. The second component, represented by
$\theta_d - \theta$, controls the steering angle to stay parallel to the path
to be followed. Together, these two components work to steer the vehicle onto
the desired path.

\subsection{Kleinsignalverhalten}

In order to better understand the behaviour of the Stanley Controller, the
controller is linearized about the point \(\left(x_V, \theta_d\right)\)=
\(\left(0, 0\right)\), which results in the following equation:
\begin{equation} 
    \bar{u} \approx \bar{\theta} + \frac{k}{v}e_{fa}.
    \label{eq:linearer Stanley-Regler} 
\end{equation}

The resulting equation \eqref{eq:linearer Stanley-Regler} has the form of a PID
(Proportional, Integral and Derivative) controller, with only P and D
components. The P component is represented by \(\frac{ke_{fa}}{v}\). As the
forward velocity for the vehicle is assumed to be constant, there is a
proportionality between the derivatives of \(e_{fa}\) with respect to time and
space. The derivative of \(e_{fa}\) with respect to space is \(\theta\).
Therefore \(\theta\) is the D component of the linearized Stanley controller.

As a consequence, the behaviour of the Stanley controller for small input
signals is similar to a PD controller with error term \(e_{fa}\). 

\subsection{Gro{\ss}signalverhalten}

For large signals the Stanley controller is dominated by the behavior of the
\(arctan(...)\) function, as well as the cyclic nature of the heading
\(\theta\). The \(arctan(...)\) function is limited between -90 and 90 degrees
and is smooth. The heading is also limited to the front semicircle, or -90 and
90 degrees, as the vehicle is assumed to be traveling in one direction.
Together these components limit the steering angle of the vehicle.

\iffalse

When dealing with large signals, the behavior of the Stanley controller is
mainly influenced by two factors: the cyclic nature of the heading \(\theta\)
and the \(arctan(...)\) function. The \(arctan(...)\) function is a smooth
function that is limited to a range between -90 and 90 degrees. On the other
hand, the heading is constrained to the front semicircle, which is between -90
and 90 degrees, as the vehicle is assumed to be traveling in one direction. As
a result, these two factors work in tandem to restrict the steering angle of
the vehicle, preventing it from becoming too large.

\fi

\section{Simulation}

\iffalse
In order to more closely investigate the behavior of the Stanley controller on
the remote controlled vehicle, a simulation of the control loop was used. The
simulation has 3 major components: first is the path that the vehicle must
follow, second is the Stanley controller and third is the vehicle model. A
differential equation solver is used in order to analyze the time series of the
two axle vehicle. 


The path that the vehicle must follow is a virtual version of the real world
track that the vehicle will use. A visual representation of the path is FIGURE.
In the simulation, the path is represented with the following continuous static
function: 
\begin{equation}
  (x, y, h) = f(t, t_f),
\end{equation}
with the inputs time $t$ and simulation end time $t_f$ and output $(x, y, h)$
as the cartesian coordinates of the path point and the heading at that point.
This function is then discretized for any chosen amount of $t$ values, in order
to create an array of (x, y, theta) values. This array is then fed into the
differential equation solver that encapsulates the Stanley controller and the
vehicle model. 

The vehicle model used is the rear axle vehicle model. This model is
represented by the following nonlinear state space representation: 
\begin{gather}
  \dot{x} = v \cos(\theta) \\
  \dot{y} = v \sin(\theta) \\
  \dot{\theta} = \frac{v}{l}\tan(\varphi) \\
  \dot{\varphi} = \frac{\left(\delta\right - u)}{T}.
\end{gather}

The state variables of the model are $x_H$, $y_H$, $\phi$ und $\theta$, where
$x_H$ und $y_H$ are the cartesian coordinates of the midpoint of the rear axle
and $\theta$ is the heading of the vehicle. $\varphi$ is the steering angle of
the vehicle. The input variables of the model are $v$ und $\varphi$, where $v$
is the velocity of the vehicle and $\varphi$ is the steering angle. The
steering angle $\varphi$ is itself a dynamic system represented by a first
order linear differential equation with the configurable time constant $T$  The
behavior of the Stanley controller when subjected to dynamic effects on the
steering angle is of great importance, as the global asymptotic stability of
the controller was only proven on the kinematic two-axle model.

As the Stanley controller requires the midpoint of the front axle for the cross
track error, it must be calculated from the rear axle. The midpoint of the
front axle is calculated from the state variables through the following static
function:
\begin{gather}
  \underline{p}_H := 
  \begin{bmatrix}
    x_H & y_H
  \end{bmatrix}^T \\
  \underline{p}_V := 
  \begin{bmatrix}
    x_V & y_V
  \end{bmatrix}^T
  \label{eq:Rear Axle and Front Axle}
\end{gather}
\begin{equation}
  \underline{p}_V = \underline{p}_H + l 
  \begin{bmatrix}
    \cos(\theta + \pi/2) \\ 
    \sin(\theta + \pi/2),
  \end{bmatrix}
  \label{eq:Transformation from Rear Axle to Front Axle}
\end{equation}
where $x_V$ and $y_V$ are the cartesian coordinates of this midpoint. 

\fi

As seen before, the Stanley controller is composed of multiple parts, which
must be seperately calculated. The heading $\theta$ is a state variable,
therefore it is always available. In order to calculate the cross track error
and the heading path, the correct path point must be chosen. The Stanley
controller uses the closest path point from the vehicle front axle midpoint to
determine the path heading $\theta_d$ and current cross track error $e_{fa}$.
For the simulation this is determined by finding the point with the smallest
distance from the front axle midpoint $\delta\underline{x}$. The path heading
is then found at this point. The dot product between the vector perpendicular
to the vehicle heading $\underline{x}_{\perp}$ and vector from the path point
to the vehicle front axle $\delta\underline{x}$ is the cross track error
$e_{fa}$. For clarity, FIGURE is a visual representation of these two vectors
and their dot product. This algorithm is represented in ALGORITHM. 
\begin{algorithm}
  \caption{Berechnung von Querabweichung}
  \label{alg:path point}
  \begin{algorithmic}
    \State $\underline{v}_{\perp} \gets \left[-\cos(\theta + \pi/2),  -\sin(\theta + \pi/2)\right]^T$
    \State $\Delta\underline{x} \gets \underline{p}_V - \underline{p}_P$
    \State $\delta\underline{x} \gets \min \left{ || \Delta\underline{x} ||_2 \right}$
    \State $\theta_d \gets \arctan\left(\frac{\frac{d}{dy}\delta\underline{x}}{\frac{d}{dx}\delta\underline{x}}\right)$
    \State $e_{fa} \gets \delta\underline{x} \cdot \underline{v}_{\perp}$
  \end{algorithmic}
\end{algorithm}


The heading path and cross track error are then fed into the Stanley
controller, whereby the output of the controller is fed into the vehicle model.
A high level diagram of the control loop is represented in FIGURE.

The Stanley controller works with continuous time signals, which is different
from what is used on the vehicle. The vehicle captures images at a specific
sampling frequency, which are then processed by the pipeline before being fed
into the controller. In order to simulate this behavior, a cache was built into
the simulator, where the heading path and cross track error are saved. The
Stanley controller is then fed these saved values for a chosen amount of time.
By caching these values, the behavior of a zero-order hold is simulated. The
output of this zero-order hold is then fed into the Stanley controller. This
allows for the behavior of the vehicle to be investigated for different
sampling frequencies, which allows for a tolerance to be set for the processing
speed of the pipeline. A comparison of the simulation at various sampling
frequencies is shown in FIGURE.

As can be seen in FIGURE, the Stanley controller is indeed affected by the
sampling frequency, however above X Hz the behavior of the vehicle is not
noticeably different. 

The simulation is then executed for a chosen amount of time. 









To gain a deeper understanding of the behavior of the Stanley controller on a
remote-controlled vehicle, we conducted a simulation of the control loop. The
simulation comprises three primary components: the path that the vehicle must
follow, the Stanley controller, and the vehicle model. We utilized a
differential equation solver to examine the time series data of the two-axle
vehicle in the simulation.


The path that the vehicle must follow is a virtual representation of the
real-world track that the vehicle will traverse. A visual depiction of the path
is provided in FIGURE. In the simulation, the path is defined by the following
continuous static function:
\begin{equation}
  (x, y, h) = f(t, t_f),
\end{equation}
where $t$ and $t_f$ are the input parameters of time and simulation end time,
respectively, and $(x, y, h)$ represents the Cartesian coordinates of the path
point and the corresponding heading at that point. This function is discretized
for a user-defined number of $t$ values to generate an array of (x, y, theta)
values. The differential equation solver incorporates the Stanley controller
and the vehicle model to analyze the time series of the two-axle vehicle using
this array as input.

The vehicle model used is the rear axle vehicle model. This model is
represented by the following nonlinear state space representation: 
\begin{gather}
  \dot{x} = v \cos(\theta) \\
  \dot{y} = v \sin(\theta) \\
  \dot{\theta} = \frac{v}{l}\tan(\varphi) \\
  \dot{\varphi} = \frac{\left(\delta\right - u)}{T}.
\end{gather}

The state variables of the model are $x_H$, $y_H$, $\phi$ und $\theta$, where
$x_H$ und $y_H$ are the cartesian coordinates of the midpoint of the rear axle
and $\theta$ is the heading of the vehicle. $\varphi$ is the steering angle of
the vehicle. The input variables of the model are $v$ und $\varphi$, where $v$
is the velocity of the vehicle and $\varphi$ is the steering angle. The
steering angle $\varphi$ is itself a dynamic system represented by a first
order linear differential equation with the configurable time constant $T$  The
behavior of the Stanley controller when subjected to dynamic effects on the
steering angle is of great importance, as the global asymptotic stability of
the controller was only proven on the kinematic two-axle model.


As the Stanley controller requires the midpoint of the front axle for the cross
track error, it must be calculated from the rear axle. The midpoint of the
front axle is calculated from the state variables through the following static
function:
\begin{gather}
  \underline{p}_H := 
  \begin{bmatrix}
    x_H & y_H
  \end{bmatrix}^T \\
  \underline{p}_V := 
  \begin{bmatrix}
    x_V & y_V
  \end{bmatrix}^T
  \label{eq:Rear Axle and Front Axle}
\end{gather}
\begin{equation}
  \underline{p}_V = \underline{p}_H + l 
  \begin{bmatrix}
    \cos(\theta + \pi/2) \\ 
    \sin(\theta + \pi/2),
  \end{bmatrix}
  \label{eq:Transformation from Rear Axle to Front Axle}
\end{equation}
where $x_V$ and $y_V$ are the cartesian coordinates of this midpoint. 

As previously discussed, the Stanley controller is composed of multiple parts, which
must be seperately calculated. The heading $\theta$ is a state variable,
therefore it is always available. In order to calculate the cross track error
and the heading path, the correct path point must be chosen. The Stanley
controller uses the closest path point from the vehicle front axle midpoint to
determine the path heading $\theta_d$ and current cross track error $e_{fa}$.
For the simulation this is determined by finding the point with the smallest
distance from the front axle midpoint $\delta\underline{x}$. The path heading
is then found at this point. The dot product between the vector perpendicular
to the vehicle heading $\underline{x}_{\perp}$ and vector from the path point
to the vehicle front axle $\delta\underline{x}$ is the cross track error
$e_{fa}$. For clarity, FIGURE is a visual representation of these two vectors
and their dot product. This algorithm is represented in ALGORITHM. 
\begin{algorithm}
  \caption{Berechnung von Querabweichung}
  \label{alg:path point}
  \begin{algorithmic}
    \State $\underline{v}_{\perp} \gets \left[-\cos(\theta + \pi/2),  -\sin(\theta + \pi/2)\right]^T$
    \State $\Delta\underline{x} \gets \underline{p}_V - \underline{p}_P$
    \State $\delta\underline{x} \gets \min \left{ || \Delta\underline{x} ||_2 \right}$
    \State $\theta_d \gets \arctan\left(\frac{\frac{d}{dy}\delta\underline{x}}{\frac{d}{dx}\delta\underline{x}}\right)$
    \State $e_{fa} \gets \delta\underline{x} \cdot \underline{v}_{\perp}$
  \end{algorithmic}
\end{algorithm}

The heading path and cross track error are then input into the Stanley
controller, and the output of the controller is fed into the vehicle model. A
high-level diagram of the control loop is illustrated in FIGURE.

The Stanley controller operates on continuous-time signals, which differs from
the discrete-time signals used by the vehicle. The vehicle captures images at a
fixed sampling frequency, which are processed by the pipeline before being fed
into the controller. To simulate this behavior, a cache is incorporated into
the simulator to store the heading path and cross track error. The Stanley
controller then uses these cached values for a specified duration. This caching
approach mimics the behavior of a zero-order hold, and the output is
subsequently fed into the Stanley controller. This simulation approach enables
the investigation of the vehicle behavior for different sampling frequencies
and permits the setting of a tolerance for the pipeline's processing speed. The
comparison of the simulation results at different sampling frequencies is
presented in FIGURE.

As depicted in FIGURE, the Stanley controller is impacted by the sampling
frequency, with a noticeable effect observed at lower frequencies. However,
above a certain threshold of X Hz, the behavior of the vehicle does not appear
to be significantly affected by the sampling frequency.

The simulation is then executed for a chosen amount of time. 

\chapter{Bildverarbeitung} 

In comparison to the PID controller used on the model vehicle, the Stanley
controller requires extra information, namely the heading of the path. An image
processing pipeline was developed in order extract this necessary information.
As can be seen in FIGURE, the pipeline is composed of multiple stages in order
to calculate the heading and cross-track-error. 


\section{Kamera-Kalibrierung} 

The start of the image processing pipeline is the camera calibration. For the
CoRoLa Car Platform, a fisheye camera was chosen as opposed to a rectilinear
camera. The benefit of a fisheye camera arises from its wider angle of view in
comparison to a rectilinear camera. However, a fisheye camera inherently has
barrel distortion causing straight lines to become curved. The curvature of
these lines is dependent on their radial distance from the center of
the image. An example can be seen in FIGURE. Compensation for this distortion
is possible through software, using the process known as camera calibration. 

Camera calibration is used in order to approximate the extrinsic and intrinsic
parameters of a camera (MATLAB). A calibrated camera allows for 3-D information
to be recovered from a 2-D image. The intrinsic parameters of a camera are
often represented by the following 3x3 matrix:
\begin{equation}
  K = 
  \begin{bmatrix} 
    f_x & 0 & c_x\\ 
    0 & f_y & c_y\\
    0 & 0 & 1 
  \end{bmatrix},
\end{equation}
where $f_x$ and $f_y$ are the focal lengths of the camera in terms of pixels in
the $x$ and $y$ directions and $c_x$ and $c_y$ are the coordinates of the
principal point. (WIKIPEDIA) The extrinsic parameters are often represented by
the following matrix: 
\begin{equation}
  \begin{bmatrix}
    R & T
  \end{bmatrix},
\end{equation}
where $R$ is the rotation matrix of the camera with respect to the world frame
and $T$ is the position column vector of the origin of the world frame
expressed in the coordinates of the camera frame. (WIKIPEDIA) The camera matrix
$M$ is the mapping from the world coordinates to pixel coordinates
represented by the matrix-matrix multiplication,
\begin{equation}
  M = K 
  \begin{bmatrix}
    R & T
  \end{bmatrix}.
\end{equation}
By recreating the $M$ matrix through software, the distorted image can be
unmapped into the world frame causing curved lines to become straight.

A camera is calibrated by using a collection of photos with known straight
lines. Commonly, a series of checkerboard images with known dimensions are
used. Photos of the checkerboard are then captured at varying angles and
locations in the scene. This series of images is then fed to the camera
calibration algorithm, which will first determine the locations of the
checkerboard squares and the lines connecting them.  Afterwards, using the
model of a fisheye camera, the algorithm compensates for the distortion. For
example, as seen in FIGURE, the curved lines of the checkerboard are made
straight again after calibration. The number of needed images is dependent on
the specific camera, however a large collection of photos will lead to a more
accurate parameter approximation. (OPENCV Citation) Using images with a higher
resolution will also lead to more accurate parameters. (OPENCV/BLOG Citation)
However, the approximated parameters are only accurate for the calibration of
images taken at the same resolution as the images used for the calibration. In
order to use the camera matrix for images with a lower resolution, the
intrinsic camera matrix $K$ must be scaled with the following formula:
\begin{equation}
  K_n = k K,
\end{equation}
where $k$ is a scalar value representing the scale-down factor. As the
intrinsic camera matrix is an instance of an affine transformation, the value
at $K_{n3, 3}$ must be set to 1. The resulting intrinsic camera matrix will
work for smaller resolutions matching the aspect ratio of the images used for
calibration, but it has been observed that when the difference in resolution is
too large, distortion is added back into the image. In FIGURE, the original
image is on the left, the middle image is calibrated using images at 900p and
the right image is calibrated using images at 240p. As can be seen, the image
on the right straightens the ruler, while the middle image leaves it curved.

One downside to camera calibration is that any calibrated image has a lower
resolution than the original image. This is a consequence of the calibration
process, as the process will distort a subset of the image, particularly
involving the pixels around the corners of the image. Therefore the calibration
process will remove these pixels from the resulting image. In order to recreate
the image in its original resolution, an interpolator is used. However, the
interpolator will return a blurrier image than the original. In order to
compensate for this, it is recommended to calibrate a camera with high
resolution images and then capture images at that resolution. Then, instead of
using the interpolator, shrink the images down to a resolution that is
necessary for the application.  This results in a more accurate image without
any blurriness. Unfortunately, this process is computationally heavy and it was
decided to only use the images from the interpolator in order to increase the
performance of the pipeline.

Another downside from the camera calibration is that the midpoint of the camera
shifts. An example of this can be seen in FIGURE. By manually
changing $c_x$, the midpoint of the image can be shifted back to its 
original location.

\section{\glqq Color Thresholding\grqq}

Next ist the the color thresholding stage of the pipeline. This stage removes
all pixels from the image that are not bright yellow.

At first, the image is filtered of all pixels without a high red component, as
bright yellow in the red, green and blue (RGB) color space has a high red
component. Afterwards, the image is converted into the hue, saturation and
value (HSV) color space. 

Under the RGB color space, pure yellow is defined as having both the red and
green channels equal to one another with the blue channel set to zero,
therefore allowing only one degree of freedom to tune the pipeline.  Having
only one degree of freedom leads to issues with tuning, as this reduces the
ability for the pipeline to account for disturbances, such as differing
lighting conditions or reflective surfaces.

Under the HSV color space, the hue channel selects the color, saturation
channel selects the purity of the hue and the value channel corresponds to the
brightness of the hue. (MS ANNO) Once the hue is selected, here yellow, the
lightness and saturation channels are then used to select the specific shade of
yellow. Using these 2 channels allows for a more robust detection of color.

In order to detect the yellow lane, the pipeline will filter out colors outside
of the yellow hue range and then truncate the lower section of the lightness
and saturation channels. As a result of this, only pure yellow is left in the
image. The values used in the pipeline for yellow is represented by the
following range, TABLE.

An example of the output from this stage of the pipeline is FIGURE.

\section{Perspektivtransformation}

The third part of the image processing pipeline is the perspective 
transformation. 

Whenever an image is captured with a camera mounted to the vehicle, the lane
line will be trapezoidal as opposed to rectangular. This perspective requires
that all calculations regarding the lane line must compensate for its
decreasing width. In order to avoid this requirement, a perspective
transformation is employed. 

Perspective transformation is the process by which
a subset of an image is sheared and made to fit the entirety of a new image. An
example is in FIGURE. For this project, the shape of the subset of the image is
a trapezoid. Using this perspective transform, the trapezoidal shape of the lane
line is corrected into one that is straight, shown in FIGURE.

A consequence of this new perspective, is that the resulting image is similar
to a 2-D plane of the track. The perspective transformation simplifies further
image processing as well, as all objects outside of the trapezoid are cropped,
leaving only the track. However, as can be seen in FIGURE, the perspective
transform introduces extra noise into the image. The shearing caused by the
perspective transform causes pixels from the original image to be stretched,
thereby polluting the image with noise. Therefore requiring that this stage
is after the color thresholding stage.

\section{Histogram}

\iffalse

After the perspective transformation stage, a histogram of the pixel density 
is created. During this step, the start point for the sliding window method is
found. 

At every column of the image, the number of white pixels are counted. 
The numbers are then placed into a list. The assumption is then that the 
columns containing the largest numbers contain the lane information. The 
index with the number is then selected as the start point for the sliding 
window method. This pipeline stage reduces computation time by filtering out 
unnecessary parts of the image not containing lane information. A visual 
representation of the histogram can be seen in FIGURE.

\fi

After the perspective transformation stage, a histogram of the pixel density is
created to determine the start point for the sliding window method. The number
of white pixels is counted for each column of the image, and these numbers are
stored in a list. The columns with the highest numbers are assumed to contain
lane information, and the index of the column with the highest number is
selected as the start point for the sliding window method. This step helps to
reduce computation time by filtering out parts of the image that do not contain
lane information. A visual representation of the histogram can be seen in
FIGURE.

\section{Gleitfenstermethode}


In the fifth stage of the pipeline, the heading and offset of the lane are
calculated through the sliding window method.

First, a chosen number of rectangles (windows) are created. The windows are
aligned in a column and equally sized. Their height is chosen so that the
column spans the entire height of the image, while their width is chosen to be
a factor of the image width. The number of windows is chosen so that the column
encompasses the white pixels representing the lane,
as can be seen in FIGURE. If the number of windows is too many, there is a
chance that the method will falsely determine white pixels deep into the image
as a part of the lane. 

Second, the x-coordinate of the center of the first window is set to the peak
of the histogram from the previous stage. Then, the number of white pixels are
counted inside the window. If the number is above a chosen threshold, the
pixels are added to an array and the mean of the x-coordinates of the contained
pixels is calculated. The x-coordinate of the next window is set to this
calculated mean while being placed on top of the first window. This process is
then repeated for all remaining windows. When no pixels are contained in a
window, the window is ignored and the following window is placed on top of it.
\iffalse
In the image coordinate system, the top left corner of the image is $(0, 0)$,
with the positive x-axis increasing to the right, while the positive y-axis
increases moving down the image. Therefore, the bottom edge of the image would
be any coordinate with a y component equal to the height of the image. Seen
from the engineer's perspective, the windows would be stacked from lowest to
highest, however in the image coordinate space it is inverted. 
\fi

The pixels not located within each window are then filtered out of the image.
The image before and after the filtering process can be seen in FIGURE. Using
the least squares method, a second order polynomial is approximated through the
remaining pixels.
In order to determine the polynomial representing the lane from the $n$ remaining pixels, the following calculation is used: \begin{gather} \underline{x} := \begin{bmatrix} x_1 & x_2 & ... & x_n \end{bmatrix}^T \\ \bold{Y} := \begin{bmatrix} 1 & y_1 & y_1^2 \\ 1 & y_2 & y_2^2 \\ \vdots & \vdots & \vdots \\ 1 & y_n & y_n^2 \end{bmatrix} \\ \underline{\hat{\beta}} := \begin{bmatrix} \hat{\beta_0} & \hat{\beta_1} & \hat{\beta_2} \end{bmatrix}^T \\ \underline{\hat{\beta}} = \left(\bold{Y}^T\bold{Y}\right)^{-1}\bold{Y}^T\underline{x}, \end{gather} where $\underline{x}$ and $\underline{y}$ are the vectors containing the x and y coordinates of the remaining pixels. $\hat{\beta_0}$, $\hat{\beta_1}$ and $\hat{\beta_2}$ are the coefficients of the approximated polynomial. 

Using the approximated coefficients, the following equation is obtained: \begin{equation} \hat{x} = \hat{\beta_0} + \hat{\beta_1}y + \hat{\beta_2}y^2, \end{equation} where $y$ is the y coordinate and $\hat{x}$ is the approximated x coordinate of the lane. The equation provides an analytical representation of the lane. 

\section{Berechnung von Ausrichtung und Abstand}
In the final stage of the pipeline, the heading and offset from the lane line
are calculated. 

From the fitted polynomial calculated in the previous stage, an analytical
heading is found at a chosen point along the path with the following equation,
\begin{equation}
  \theta = \arctan(f^\prime(y)).
\end{equation}
The inverse tangent of the derivative of
the polynomial returns the heading at a chosen point. For the Stanley
controller, only the difference between the path heading and vehicle heading
is needed as there is no global frame for the vehicle, the heading
of the vehicle is chosen to be zero degrees at all times. PICTURE WITH VISUAL
REPRSENTATION 

The classic Stanley controller, as described in chapter 2, uses the heading
calculated from the nearest path point. However, as a side effect of the
polynomial fitting, the heading calculated at the bottom of the image is
incorrect. As can be seen in FIGURE, the sliding window method cannot consistently
detect the lane line at the bottom of the frame. Due to this, the
fitted polynomial incorrectly approximates the heading. Therefore, the heading
is calculated at a point located within the detected lane line instead.
Moreover, this adds a degree of freedom to the controller. The consequences of
this are discussed in chapter 4.

The offset from the lane line is calculated from the fitted polynomial with
the following function: $$e_{fa} = (\frac{w}{2} - f(h))\cdot x_{mpp},$$ where
$w$ is the width of the image, $f(h)$ is the output of the fitted polynomial
at the bottom of the image, $x_{mpp}$ is a scaling constant to translate
pixels into meters and $e_{fa}$ is the offset from the vehicle to the lane.
All together, the difference of the x-component of the midpoint and the
x-component of the polynomial point located on the bottom edge of the image is
translated into meters.

\section{Ausrei{\ss}er}

\iffalse

A side effect of the sliding window method is a phenomenom termed "outliers".
Outliers are any frame where the lane line is incorrectely determined. In
FIGURE, a sequence of three frames with an outlier are observed with the left
frame being the start. In the first frame, the lane line is correctly
determined. In the second frame, the lane line is incorrectly determined. In
the last frame, the lane line is once again correctly determined. The incorrect
selection of HSV values is the largest contributor to the occurence of
outliers. When the HSV values are not restrictive enough, colors besides yellow
are not filtered out of the image. Which leads to incorrect determination of
the lane line.

Outliers are most common on the curves of the track, due a disadvantage of the
pipeline implementation. As discussed previously, the first window of the
sliding window method is selected at the x-position of the peak of the pixel
histogram. Along the straight part of the track, the lane line is the densest
object in the image. Therefore the peak of the histogram will be along the lane
line. Along the curves, the lane line will be spread across the x-axis leading
to a reduced peak in the histogram. A visual representation can be seen in
FIGURE. A combination of the two previous factors led to the outlier seen in
FIGURE.

\fi

Lane detection algorithms may cause a phenomenon known as a "outlier". These
occur when a algorithm incorrectly determines the lane line in a given frame.
As an example, FIGURE shows a sequence of three frames being processed by the
sliding window method, with the leftmost frame being the starting point. The
first frame accurately detects the lane line, but in the second frame, an
outlier occurs where the lane line is incorrectly determined. In the final
frame, the lane line is once again correctly identified.

One of the primary causes of outliers is the incorrect selection of HSV values.
When the HSV values used in the algorithm are not restrictive enough, colors
besides yellow may not be filtered out, leading to inaccurate determination of
the lane line.

Outliers are particularly prevalent on curved sections of a track due to a
limitation of the pipeline implementation. As explained earlier, the first
window of the sliding window method is placed at the x-position of the peak of
the pixel histogram. Along the straight portions of the track, the lane line is
the most prominent object in the image, resulting in a peak at the lane line
position in the histogram. However, along curves, the lane line is distributed
across the x-axis, leading to a weaker peak in the histogram. This can be seen
visually in FIGURE. The outlier observed in FIGURE is a result of both these
factors combined.

The image processing used for the PID controller and Stanley controller are 
victims to this phenomenon.

\section{Pipeline-Optimierungen}

One of the obstacles encountered during the development of the image processing
pipeline, is that the runtime of the pipeline was too slow. In order to improve
the processing speed of the pipeline to an acceptable level, one optimization
was introduced. While further optimizations are possible, they were considered
to be out of the scope of the assignment and are therefore not discussed here.

The Python program cProfiler was used in order to tabulate the pipeline
function calls with their respective runtimes. As the pipeline is a
deterministic program, caching the output of the expensive function calls into
memory improves the runtime of the pipeline. Therefore during all subsequent
pipeline executions, the cached result is returned instead of running the
calculation again. As an example, calculation of the the perspective
transformation matrices are expensive, which when cached leads to a performance
improvement of the pipeline.

In order to prove the performance improvement of the pipeline, an experiment
was implemented. First, the pipeline is executed once and the runtime ignored
as the performance improvement is only relevant to subsequent executions of the
pipeline. Therefore, on the second execution of the pipeline, the runtime is
measured for both pipeline variants, with and without caching the expensive
function calls from the first execution. The experiment is then run 100 times
and the result tabulated. The arithmetic mean of the runtimes for both variants
are then compared to one another to measure the runtime improvement. The
experiment showed that the caching of these function calls lowered the runtime
from X ms to Y ms.

\chapter{Experiment}
\section{Hardware}

The CoRoLa car platform is composed of a Raspberry Pi, a fisheye lens camera, a
DC motor and a motor controller to control the vehicle speed and a servo motor
to control the steering angle of the vehicle. The Raspberry Pi sends PWM
signals to the motor controller and the servo controller with a sampling rate
of 50 Hz in order to control the vehicle. 

\section{Experimentkriterien}

In order to compare the Stanley controller and the sliding window method with
the PID controller, 4 test criteria are chosen: maximum acceptable velocity and
maximum offset angles, as well as the mean values of the vehicle
offset and controller outputs.

\subsection{H"ochstgeschwindigkeit}

In order to measure the maximum acceptable velocity, vehicle drives around the
track at a given forward velocity. If the behavior of the vehicle is seen as
"acceptable", then the vehicle is stopped and the velocity is increased. This
process repeats until the behavior of the vehicle is no longer "acceptable".
"Acceptable" behavior of the vehicle is defined empirically under the following
two criteria: ability to follow the lane line and an absence of observed
oscillations.

\subsection{Maximal m"oglicher Fehlerwinkel}

The maximum offset angles are defined as the maximum angles at which the
vehicle is able to find the path again, on the left and right of the lane line
respectively. In order to measure this, the vehicle is placed collinear with
the lane line with the motor controller disabled. The vehicle is then turned
clockwise, with the output of the respective controller displayed in realtime.
The vehicle is turned until the output of the controller becomes either chaotic
or the output is consistently zero. The experiment is then executed for the
Stanley Controller and PID Controller. The occurence of chaotic output is
nondeterministic, however empirically it is when the vehicle cannot detect the
lane line reliably. An output of zero also means that the vehicle cannot detect
the lane line at all.

\subsection{Abstand von der Linie}

The measurement of vehicle offset is conducted through the following two
experiments. First, the vehicle starts driving around the track with a selected
forward velocity. Then using an overhead camera, video of the vehicle driving
around the curves is recorded from a top down view. The vehicle is recorded at
differing forward velocities. For the first round of recordings, the vehicle is
controlled by the PID controller and for the second, it is controlled by the
Stanley controller. This experiment is executed for the chosen velocities
of 1.0, 1.25, 1.5, 1.75 and 2.0 meters per second.

\subsection{Reglerausgang}

In order to measure the controller output of the two controllers, the vehicle
is commanded to drive around the track at least three times. During the drive,
the controller output is recorded. After the drive, the data is graphed over
time and a subset of the data is selected. The subset of the data is selected
under the following criteria: periodicity and absence of outliers.

\section{Ergebnisse}

The results of the experiments are listed in TABLE. 

\subsection{H"ochstgeschwindigkeit}
When the PID controller is used on the vehicle, velocities exceeding 1.5 $m/s$
result in reduced robustness. In contrast to the Stanley controller, the PID
controller causes the vehicle to oscillate when an outlier occurs and requires
more time to return to the lane. The magnitude of the oscillations increases
with the forward velocity of the vehicle. If the velocity exceeds 2.0 $m/s$,
the PID controller will steer the vehicle into the track wall. Even velocities
between 1.5 and 1.75 $m/s$ require supervision to avoid collisions.

In comparison, the Stanley controller requires no supervision until the forward
velocity of the vehicle reaches 2.3 $m/s$. However, at higher velocities, the
vehicle deviates further from the desired path until it acts as a guide rather
than something that needs to be followed.
\iffalse
When running the PID controller on the vehicle, velocities above $1.5 \frac{m}{s}$
lead to issues with the robustness of the vehicle. In comparison to then Stanley 
controller, whenever an outlier appears, the PID controller causes the vehicle to oscillate and
requires a longer time than the Stanley controller to return to the lane. The oscillations 
scale with the forward velocity of the vehicle. With velocities greater than or equal to 
$2.0 \frac{m}{s}$, the PID controller will drive the vehicle into the wall of the track. Even 
velocities between 1.5 and 1.75 $\frac{m}{s}$ require supervision in order to make sure that the 
vehicle won't drive into the wall.

In comparsion, the Stanley controller requires no supervision, until the
forward velocity of the vehicle is above 2.3 $\frac{m}{s}$. However, at higher
velocities, the vehicle will drift farther from the path, until the vehicle
acts as a "guide", as opposed to something that needs to be followed. 
\fi

\subsection{Maximal m"oglicher Fehlerwinkel}

The Stanley controller can not be offset from the lane as much as the PID
controller. Due to both the calibration stage of the pipeline and requiring an
approximated polynomial, the requirements for the Stanley controller to detect
the lane are higher than the PID controller. The PID controller requires only
that a grouping of yellow pixels exists in the image. The Stanley controller
requires at least some geometry to the grouping of yellow pixels, typically in
the form of a line or section of a curve.

\subsection{Abstand von der Linie}

As can be seen in FIGURE, the PID controller follows the path closer than the
Stanley controller. Even accounting for the offset at the start of the curve,
the Stanley controller does not drive the vehicle onto the lane until the end
of the curve. In comparison, the PID controller forces the vehicle to stay on
the path, while still drifting lightly to the left. This drift scales with the
forward velocity of the vehicle.

When comparing the results of the simulation of the Stanley controller in
FIGURE with $v = 1.75 \frac{m}{s}$ and $fs = 50$ Hz and its behaviour on the
track, the behaviour of the Stanley controller in reality matches with the
simulation. However, as can be seen in FIGURE, the Stanley controller will
drift away from the straight section of the track before the curve. 

Compensation for this drift was attempted, but outside of setting the reference
point for the cross-track-error to another value, the drift stayed. By changing
the reference point manually, the vehicle requires different parameters when
driving clockwise or counterclockwise around the track. To avoid this, it was
decided to keep the drift included for now. In chapter 5, adjustments to the
Stanley controller are discussed, that could lead to an improvement in the
future.


\subsection{Reglerausgang}

The controller output of both controllers are similar, regardless of the
velocity, except for the PID controller at velocity 1.5 $\frac{m}{s}$. As the
forward velocity of the vehicle increases, the controller output scales
appropiately. The difference between the two controllers comes in the form of
both signals. Between forward velocities 1.0 and 1.5 $\frac{m}{s}$, the signal
output of the two controllers are similar, however at 1.75 and 2.0
$\frac{m}{s}$ the sinusoidal nature of the PID controller degrades, while the
sinusoidal nature of the Stanley controller increases. 

At 1.75 $\frac{m}{s}$, the PID controller can still control the vehicle onto
the lane, however as can be seen in FIGURE, outliers lead to high oscillations
in controller output. When the PID controller incorrectly identifies the lane,
the controller has difficulty returning the vehicle to the lane and can instead
drive the vehicle into the wall, which can be seen at the right end of the
graph. In comparison, the Stanley controller has no issue following the path at
the same velocity. 

At 2.0 $\frac{m}{s}$, the PID controller is unable to control the vehicle and
drives the vehicle into the wall. As can be seen in FIGURE, the output varies
between -30 and 30 degrees and there is no periodicity. In comparision, the
Stanley controller has a stable oscillation between -30 and 0 degrees and is
periodic.

Outliers do not lead to high oscillations when the vehicle is being controlled
by the Stanley controller. It has been observed that the vehicle will reorient
itself onto the path much quicker than the PID controller.



\chapter{Conclusion}

\iffalse
When comparing only the path following behaviour of both controllers, the PID
controller is still the best choice. However, when factoring in the other
aspects of the problem statement, the Stanley controller is a better fit for
the application. As the vehicle needs to be able to drive autonomously without
supervision at a higher velocity than it can originally, the Stanley controller
fulfills these requirements. 
\fi

The path following behavior of both controllers has been evaluated, and while
the PID controller may perform better in this aspect, other factors of the
problem statement need to be considered to determine the better fit for the
application. In this case, the Stanley controller proves to be more suitable
for the autonomous driving application, as it is capable of handling higher
velocities without supervision. Therefore, when taking into account all aspects
of the problem statement, the Stanley controller is the better choice for this
application.

\subsection{Future Work}

By the conclusion of this paper, it was observed that the vehicle still drifts
away from the lane before each curve. In order to address this issue, it is
proposed to adjust the Stanley controller by adding an integrator to compensate
for this drift. The adjusted Stanley controller is given by the following
equation:

\begin{equation}
u = \theta - \theta_d + \arctan\left(\frac{ke_{V}}{v}\right) + k_{i} \int_{0}^{t} e_{V},d\tau,
\label{eq:Stanley-Regler-adjusted}
\end{equation}

In linear control theory, an integrator is used to remove residual error from
an application. As the small signal version of the Stanley controller is a PD
controller, it is hypothesized that adding an integrator will correct the
observed drift. As shown in the figure, the drift is apparent in the input to
the controller. By integrating the offset, it is proposed that over time the
drift will be compensated for and the vehicle will stay on the lane. Further
research is needed to test this hypothesis and verify the effectiveness of the
proposed adjustment.

\iffalse
By the conclusion of this paper, the vehicle still drifts away from the
lane before each curve. In the future, it is proposed to adjust the Stanley
controller to include an integrator in order to compensate for this drift.
The adjusted Stanley controller has the form of the following equation:

\begin{equation} 
    u = \theta - \theta_d + \arctan\left(\frac{ke_{fa}}{v}\right) + k_{i} \int_{0}^{\infty} e_{fa}\,dt, 
    \label{eq:Stanley-Regler-adjusted} 
\end{equation}

In linear control theory, an integrator is used in order to remove residual
error from an application. As the small signal version of the Stanley
controller is a PD controller, it is hypothesized that an integrator will 
correct this observed drift. As can be seen in FIGURE, the drift is apparent in
the input to the controller. By integrating the offset it is proposed that
over time the drift will be componsated for and the vehicle stay on the lane. 
\fi


\end{document}
