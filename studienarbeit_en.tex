%! TEX program = pdflatex
\documentclass[arbeit=studie,oneside,BCOR=12mm]{ArbeitRST}
\usepackage{amsmath} 
\hypersetup{
  unicode=false,          % non-Latin characters in Acrobat’s bookmarks
  pdftoolbar=true,        % show Acrobat’s toolbar?
  pdfmenubar=true,        % show Acrobat’s menu?
  pdffitwindow=false,     % window fit to page when opened
  pdfstartview={FitH},    % fits the width of the page to the window
  pdftitle={Verbessung der Spurerkennung und -verfolgung autonomer Modellfahrzeuge}, % title
  pdfauthor={James Vero Asghar},     % author
  pdfsubject={Subject},   % subject of the document
  pdfcreator={James Vero Asghar},   % creator of the document
  pdfproducer={Producer}, % producer of the document
  pdfkeywords={Stanley controller} {sliding window method} {model cars}, % list of keywords
  pdfnewwindow=true,      % links in new window
  colorlinks=true,        % false: boxed links; true: colored links
  linkcolor=blue,         % color of internal links (change box color with linkbordercolor)
  citecolor=green,        % color of links to bibliography
  filecolor=magenta,      % color of file links
  urlcolor=cyan           % color oPf external links
  }
\setlength{\parindent}{0ex}
\setlength{\parskip}{2ex}
\usepackage{algorithm}
\usepackage{algpseudocode}

% Entfernt die farbigen Markierungen - bitte Druckversion mit dieser Option kompilieren
%\hypersetup{hidelinks}

\begin{document}

% Titelseite
% ==========

% Name des Verfassers
\author{James Vero Asghar}

% Geburtsort
\geburtsort{Austin, Texas, Vereignete Staaten}

% Geburtsdatum
\geburtsdatum{3. Dezember 1997}

% Titel der Arbeit
\title{Verbesserung der Spurerkennung und -verfolgung autonomer Modellfahrzeuge}

% Untertitel
\subtitle{}

% Angabe der Betreuer
\betreuer{Dr.-Ing. Carsten Knoll}
\betreuer{M.Sc. Paul Auerbach}

% Datum der Einreichung
\date{2. Februar 2222}


% Zunächst für das Vorgeplänkel römische Seitenzahlen und einfacher Seitenstil
% ============================================================================
\pagenumbering{Roman}
\pagestyle{plain}


% Titelseite erstellen
\maketitle


% Selbstständigkeitserklärung
% ===========================

% Selbstständigkeitserklärung erstellen
\selbststaendigkeitserklaerung


% Kurzfassung / Abstract
% ======================
\kurzfassung{An dieser Stelle fügen Sie bitte eine deutsche Kurzfassung ein.}
{At the Connected Robotics Lab (CoRoLa) research group at the Barkhausen
Institut, a demonstration using remote controlled 2 axis vehicles was
developed. The demonstration is currently in use in order to model
communications between vehicles similar to an Internet of Things (IoT) network.

In order to better model the complexities of a real world system a nonlinear
control algorithm was introduced to the system in order to more accurately
control the vehicles. The Stanley Controller is a nonlinear controller
developed for use with the lateral control of 2 axis vehicles in mind. As input
to the controller, a fisheye camera was used to create images of road. These
images were then digitally processed to find the yellow line for the vehicles
to follow.}


% Inhaltsverzeichnis
% ==================
\tableofcontents

\chapter{Einführung}

\chapter{Regelalgorithmus}

\section{Stanley-Regler}
\iffalse
The Stanley controller is a non-linear control algorithm developed in 2005 by
Stanford University. It was developed in order to control a 2 axle vehicle
using only the heading and the cross track error from the path to be followed.
It was proven to be asymptotically global stable for the kinematic model of a
two axle vehicle .However in for the duration of this thesis the the model used
is not the kinematic model of a 2 axle vehicle instead a model that also
accounts for the dynamics of the steering angle.

The stanley controller is a path following controller as opposed to a
trajectory following algorithm. The stanley controller is designed as a lateral
controller,  so that the vehicle stays on the path, but has no bearing on the
speed at which it will follow the path. The positives of this approach allow
for a flexible choice of the speed of the vehicle, which barring dynamic
effects, allows for a engineer to choose any speed necessary for their
application.

The stanley controller is represented by the following equation: $$u = \theta_d
- \theta + \arctan\left(\frac{ke_{fa}}{v}\right),$$ where $u$ is the controller
output, $\theta$ is the current heading of the vehicle, $\theta_d$ is the
heading of the path, $k$ is a scaling factor, $v$ is the velocity of the
vehicle, and $e_{fa}$ is the cross track error from the midpoint of the
vehicle’s front axle to the path. 

The stanley controller is composed of two components:  a component handling the
offset of the vehicle from the path and a component handling the derivative of
the offset (difference in heading).  The first component, represented by
$\arctan(\frac{ke_{fa}}{v})$,  drives the steering angle to turn more towards
the path, the farther away the car currently is. The second component,
represented by $\theta_d - \theta$, controls the steering angle to stay
parallel with the path to be followed. Working together, the two components
steer the vehicle on to the path to be followed.

\fi

The Stanley controller is a non-linear control algorithm that was developed in
2005 by Stanford University with the purpose of controlling a two-axle vehicle
using only the heading and the cross track error from the path to be followed.
The algorithm has been proven to be asymptotically globally stable for the
kinematic model of a two-axle vehicle. (STANFORD)

The Stanley controller is a path following controller instead of a trajectory
following controller. As a lateral controller, it is designed to keep the
vehicle on the path but has no impact on the speed at which the vehicle travels
along the path. This approach allows for a flexible choice of the vehicle
speed, which can be selected as required for a given application, subject to
dynamic effects. The Stanley controller is represented mathematically by the
following equation: \begin{equation} u = \theta - \theta_d +
\arctan\left(\frac{ke_{fa}}{v}\right), \label{eq:Stanley-Regler} \end{equation}
where $u$ represents the controller output, $\theta$ is the current heading of
the vehicle, $\theta_d$ is the heading of the path, $k$ is a scaling factor,
$v$ is the velocity of the vehicle, and $e_{fa}$ is the cross track error from
the midpoint of the vehicle's front axle to the path.

The Stanley controller consists of two components: a component that handles the
offset of the vehicle from the path and a component handles the difference in
vehicle heading and path heading. The first component is represented by
$\arctan(\frac{ke_{fa}}{v})$ and drives the steering angle to turn towards the
path as the car gets farther away from it. The second component, represented by
$\theta_d - \theta$, controls the steering angle to stay parallel to the path
to be followed. Together, these two components work to steer the vehicle onto
the desired path.

\subsection{Kleinsignalverhalten}

In order to better understand the behaviour of the Stanley Controller, the
controller is linearized about the point \(\left(x_V, \theta_d\right)\)=
\(\left(0, 0\right)\), which results in the following equation:
\begin{equation} 
    \bar{u} \approx \bar{\theta} + \frac{k}{v}e_{fa}.
    \label{eq:linearer Stanley-Regler} 
\end{equation}

The resulting equation \eqref{eq:linearer Stanley-Regler} has the form of a PID
(Proportional, Integral and Derivative) controller, with only P and D
components. The P component is represented by \(\frac{ke_{fa}}{v}\). As the
forward velocity for the vehicle is assumed to be constant, there is a
proportionality between the derivatives of \(e_{fa}\) with respect to time and
space. The derivative of \(e_{fa}\) with respect to space is \(\theta\).
Therefore \(\theta\) is the D component of the linearized Stanley controller.

As a consequence, the behaviour of the Stanley controller for small input
signals is similar to a PD controller with error term \(e_{fa}\). 

\subsection{Gro{\ss}signalverhalten}

For large signals the Stanley controller is dominated by the behavior of the
\(arctan(...)\) function, as well as the cyclic nature of the heading
\(\theta\). The \(arctan(...)\) function is limited between -90 and 90 degrees
and is smooth. The heading is also limited to the front semicircle, or -90 and
90 degrees, as the vehicle is assumed to be traveling in one direction.
Together these components limit the steering angle of the vehicle.

\iffalse

When dealing with large signals, the behavior of the Stanley controller is
mainly influenced by two factors: the cyclic nature of the heading \(\theta\)
and the \(arctan(...)\) function. The \(arctan(...)\) function is a smooth
function that is limited to a range between -90 and 90 degrees. On the other
hand, the heading is constrained to the front semicircle, which is between -90
and 90 degrees, as the vehicle is assumed to be traveling in one direction. As
a result, these two factors work in tandem to restrict the steering angle of
the vehicle, preventing it from becoming too large.

\fi

\section{Simulation}

\iffalse
In order to more closely investigate the behavior of the Stanley controller on
the remote controlled vehicle, a simulation of the control loop was used. The
simulation has 3 major components: first is the path that the vehicle must
follow, second is the Stanley controller and third is the vehicle model. A
differential equation solver is used in order to analyze the time series of the
two axle vehicle. 


The path that the vehicle must follow is a virtual version of the real world
track that the vehicle will use. A visual representation of the path is FIGURE.
In the simulation, the path is represented with the following continuous static
function: 
\begin{equation}
  (x, y, h) = f(t, t_f),
\end{equation}
with the inputs time $t$ and simulation end time $t_f$ and output $(x, y, h)$
as the cartesian coordinates of the path point and the heading at that point.
This function is then discretized for any chosen amount of $t$ values, in order
to create an array of (x, y, theta) values. This array is then fed into the
differential equation solver that encapsulates the Stanley controller and the
vehicle model. 

The vehicle model used is the rear axle vehicle model. This model is
represented by the following nonlinear state space representation: 
\begin{gather}
  \dot{x} = v \cos(\theta) \\
  \dot{y} = v \sin(\theta) \\
  \dot{\theta} = \frac{v}{l}\tan(\varphi) \\
  \dot{\varphi} = \frac{\left(\delta\right - u)}{T}.
\end{gather}

The state variables of the model are $x_H$, $y_H$, $\phi$ und $\theta$, where
$x_H$ und $y_H$ are the cartesian coordinates of the midpoint of the rear axle
and $\theta$ is the heading of the vehicle. $\varphi$ is the steering angle of
the vehicle. The input variables of the model are $v$ und $\varphi$, where $v$
is the velocity of the vehicle and $\varphi$ is the steering angle. The
steering angle $\varphi$ is itself a dynamic system represented by a first
order linear differential equation with the configurable time constant $T$  The
behavior of the Stanley controller when subjected to dynamic effects on the
steering angle is of great importance, as the global asymptotic stability of
the controller was only proven on the kinematic two-axle model.

As the Stanley controller requires the midpoint of the front axle for the cross
track error, it must be calculated from the rear axle. The midpoint of the
front axle is calculated from the state variables through the following static
function:
\begin{gather}
  \underline{p}_H := 
  \begin{bmatrix}
    x_H & y_H
  \end{bmatrix}^T \\
  \underline{p}_V := 
  \begin{bmatrix}
    x_V & y_V
  \end{bmatrix}^T
  \label{eq:Rear Axle and Front Axle}
\end{gather}
\begin{equation}
  \underline{p}_V = \underline{p}_H + l 
  \begin{bmatrix}
    \cos(\theta + \pi/2) \\ 
    \sin(\theta + \pi/2),
  \end{bmatrix}
  \label{eq:Transformation from Rear Axle to Front Axle}
\end{equation}
where $x_V$ and $y_V$ are the cartesian coordinates of this midpoint. 

\fi

As seen before, the Stanley controller is composed of multiple parts, which
must be seperately calculated. The heading $\theta$ is a state variable,
therefore it is always available. In order to calculate the cross track error
and the heading path, the correct path point must be chosen. The Stanley
controller uses the closest path point from the vehicle front axle midpoint to
determine the path heading $\theta_d$ and current cross track error $e_{fa}$.
For the simulation this is determined by finding the point with the smallest
distance from the front axle midpoint $\delta\underline{x}$. The path heading
is then found at this point. The dot product between the vector perpendicular
to the vehicle heading $\underline{x}_{\perp}$ and vector from the path point
to the vehicle front axle $\delta\underline{x}$ is the cross track error
$e_{fa}$. For clarity, FIGURE is a visual representation of these two vectors
and their dot product. This algorithm is represented in ALGORITHM. 
\begin{algorithm}
  \caption{Berechnung von Querabweichung}
  \label{alg:path point}
  \begin{algorithmic}
    \State $\underline{v}_{\perp} \gets \left[-\cos(\theta + \pi/2),  -\sin(\theta + \pi/2)\right]^T$
    \State $\Delta\underline{x} \gets \underline{p}_V - \underline{p}_P$
    \State $\delta\underline{x} \gets \min \left{ || \Delta\underline{x} ||_2 \right}$
    \State $\theta_d \gets \arctan\left(\frac{\frac{d}{dy}\delta\underline{x}}{\frac{d}{dx}\delta\underline{x}}\right)$
    \State $e_{fa} \gets \delta\underline{x} \cdot \underline{v}_{\perp}$
  \end{algorithmic}
\end{algorithm}


The heading path and cross track error are then fed into the Stanley
controller, whereby the output of the controller is fed into the vehicle model.
A high level diagram of the control loop is represented in FIGURE.

The Stanley controller works with continuous time signals, which is different
from what is used on the vehicle. The vehicle captures images at a specific
sampling frequency, which are then processed by the pipeline before being fed
into the controller. In order to simulate this behavior, a cache was built into
the simulator, where the heading path and cross track error are saved. The
Stanley controller is then fed these saved values for a chosen amount of time.
By caching these values, the behavior of a zero-order hold is simulated. The
output of this zero-order hold is then fed into the Stanley controller. This
allows for the behavior of the vehicle to be investigated for different
sampling frequencies, which allows for a tolerance to be set for the processing
speed of the pipeline. A comparison of the simulation at various sampling
frequencies is shown in FIGURE.

As can be seen in FIGURE, the Stanley controller is indeed affected by the
sampling frequency, however above X Hz the behavior of the vehicle is not
noticeably different. 

The simulation is then executed for a chosen amount of time. 









To gain a deeper understanding of the behavior of the Stanley controller on a
remote-controlled vehicle, we conducted a simulation of the control loop. The
simulation comprises three primary components: the path that the vehicle must
follow, the Stanley controller, and the vehicle model. We utilized a
differential equation solver to examine the time series data of the two-axle
vehicle in the simulation.


The path that the vehicle must follow is a virtual representation of the
real-world track that the vehicle will traverse. A visual depiction of the path
is provided in FIGURE. In the simulation, the path is defined by the following
continuous static function:
\begin{equation}
  (x, y, h) = f(t, t_f),
\end{equation}
where $t$ and $t_f$ are the input parameters of time and simulation end time,
respectively, and $(x, y, h)$ represents the Cartesian coordinates of the path
point and the corresponding heading at that point. This function is discretized
for a user-defined number of $t$ values to generate an array of (x, y, theta)
values. The differential equation solver incorporates the Stanley controller
and the vehicle model to analyze the time series of the two-axle vehicle using
this array as input.

The vehicle model used is the rear axle vehicle model. This model is
represented by the following nonlinear state space representation: 
\begin{gather}
  \dot{x} = v \cos(\theta) \\
  \dot{y} = v \sin(\theta) \\
  \dot{\theta} = \frac{v}{l}\tan(\varphi) \\
  \dot{\varphi} = \frac{\left(\delta\right - u)}{T}.
\end{gather}

The state variables of the model are $x_H$, $y_H$, $\phi$ und $\theta$, where
$x_H$ und $y_H$ are the cartesian coordinates of the midpoint of the rear axle
and $\theta$ is the heading of the vehicle. $\varphi$ is the steering angle of
the vehicle. The input variables of the model are $v$ und $\varphi$, where $v$
is the velocity of the vehicle and $\varphi$ is the steering angle. The
steering angle $\varphi$ is itself a dynamic system represented by a first
order linear differential equation with the configurable time constant $T$  The
behavior of the Stanley controller when subjected to dynamic effects on the
steering angle is of great importance, as the global asymptotic stability of
the controller was only proven on the kinematic two-axle model.


As the Stanley controller requires the midpoint of the front axle for the cross
track error, it must be calculated from the rear axle. The midpoint of the
front axle is calculated from the state variables through the following static
function:
\begin{gather}
  \underline{p}_H := 
  \begin{bmatrix}
    x_H & y_H
  \end{bmatrix}^T \\
  \underline{p}_V := 
  \begin{bmatrix}
    x_V & y_V
  \end{bmatrix}^T
  \label{eq:Rear Axle and Front Axle}
\end{gather}
\begin{equation}
  \underline{p}_V = \underline{p}_H + l 
  \begin{bmatrix}
    \cos(\theta + \pi/2) \\ 
    \sin(\theta + \pi/2),
  \end{bmatrix}
  \label{eq:Transformation from Rear Axle to Front Axle}
\end{equation}
where $x_V$ and $y_V$ are the cartesian coordinates of this midpoint. 

As previously discussed, the Stanley controller is composed of multiple parts, which
must be seperately calculated. The heading $\theta$ is a state variable,
therefore it is always available. In order to calculate the cross track error
and the heading path, the correct path point must be chosen. The Stanley
controller uses the closest path point from the vehicle front axle midpoint to
determine the path heading $\theta_d$ and current cross track error $e_{fa}$.
For the simulation this is determined by finding the point with the smallest
distance from the front axle midpoint $\delta\underline{x}$. The path heading
is then found at this point. The dot product between the vector perpendicular
to the vehicle heading $\underline{x}_{\perp}$ and vector from the path point
to the vehicle front axle $\delta\underline{x}$ is the cross track error
$e_{fa}$. For clarity, FIGURE is a visual representation of these two vectors
and their dot product. This algorithm is represented in ALGORITHM. 
\begin{algorithm}
  \caption{Berechnung von Querabweichung}
  \label{alg:path point}
  \begin{algorithmic}
    \State $\underline{v}_{\perp} \gets \left[-\cos(\theta + \pi/2),  -\sin(\theta + \pi/2)\right]^T$
    \State $\Delta\underline{x} \gets \underline{p}_V - \underline{p}_P$
    \State $\delta\underline{x} \gets \min \left{ || \Delta\underline{x} ||_2 \right}$
    \State $\theta_d \gets \arctan\left(\frac{\frac{d}{dy}\delta\underline{x}}{\frac{d}{dx}\delta\underline{x}}\right)$
    \State $e_{fa} \gets \delta\underline{x} \cdot \underline{v}_{\perp}$
  \end{algorithmic}
\end{algorithm}

The heading path and cross track error are then input into the Stanley
controller, and the output of the controller is fed into the vehicle model. A
high-level diagram of the control loop is illustrated in FIGURE.

The Stanley controller operates on continuous-time signals, which differs from
the discrete-time signals used by the vehicle. The vehicle captures images at a
fixed sampling frequency, which are processed by the pipeline before being fed
into the controller. To simulate this behavior, a cache is incorporated into
the simulator to store the heading path and cross track error. The Stanley
controller then uses these cached values for a specified duration. This caching
approach mimics the behavior of a zero-order hold, and the output is
subsequently fed into the Stanley controller. This simulation approach enables
the investigation of the vehicle behavior for different sampling frequencies
and permits the setting of a tolerance for the pipeline's processing speed. The
comparison of the simulation results at different sampling frequencies is
presented in FIGURE.

As depicted in FIGURE, the Stanley controller is impacted by the sampling
frequency, with a noticeable effect observed at lower frequencies. However,
above a certain threshold of X Hz, the behavior of the vehicle does not appear
to be significantly affected by the sampling frequency.

The simulation is then executed for a chosen amount of time. 

\chapter{Bildverarbeitung} 

\section{Kamera-Kalibrierung} 

The start of the image processing pipeline is the camera calibration. For the
CoRoLa Car Platform, a fisheye camera was chosen as opposed to a rectilinear
camera. The benefit of a fisheye camera arises from its wider angle of view in
comparison to a rectilinear camera. However, a fisheye camera inherently has
barrel distortion causing straight lines to become curved. The curvature of
these lines is dependent on their radial distance from the center of
the image. An example can be seen in FIGURE. Compensation for this distortion
is possible through software, using the process known as camera calibration. 

Camera calibration is used in order to approximate the extrinsic and intrinsic
parameters of a camera (MATLAB). A calibrated camera allows for 3-D information
to be recovered from a 2-D image. The intrinsic parameters of a camera are
often represented by the following 3x3 matrix:
\begin{equation}
  K = 
  \begin{bmatrix} 
    f_x & 0 & c_x\\ 
    0 & f_y & c_y\\
    0 & 0 & 1 
  \end{bmatrix},
\end{equation}
where $f_x$ and $f_y$ are the focal lengths of the camera in terms of pixels in
the $x$ and $y$ directions and $c_x$ and $c_y$ are the coordinates of the
principal point. (WIKIPEDIA) The extrinsic parameters are often represented by
the following matrix: 
\begin{equation}
  \begin{bmatrix}
    R & T
  \end{bmatrix},
\end{equation}
where $R$ is the rotation matrix of the camera with respect to the world frame
and $T$ is the position column vector of the origin of the world frame
expressed in the coordinates of the camera frame. (WIKIPEDIA) The camera matrix
$M$ is the mapping from the world coordinates to pixel coordinates
represented by the matrix-matrix multiplication,
\begin{equation}
  M = K 
  \begin{bmatrix}
    R & T
  \end{bmatrix}.
\end{equation}
By recreating the $M$ matrix through software, the distorted image can be
unmapped into the world frame causing curved lines to become straight.

A camera is calibrated by using a collection of photos with known straight
lines. Commonly, a series of checkerboard images with known dimensions are
used. Photos of the checkerboard are then captured at varying angles and
locations in the scene. This series of images is then fed to the camera
calibration algorithm, which will first determine the locations of the
checkerboard squares and the lines connecting them.  Afterwards, using the
model of a fisheye camera, the algorithm compensates for the distortion of the
fisheye camera. For example, as seen in FIGURE, the curved lines of the
checkerboard are made straight again after calibration. The number of needed
images is dependent on the specific camera, however a large collection of
photos will lead to a more accurate parameter approximation. (OPENCV Citation)
Using images with a higher resolution will also lead to more accurate
parameters. (OPENCV/BLOG Citation) However, the approximated parameters are
only accurate for the calibration of images taken at the same resolution as the
images used for the calibration. In order to use the camera matrix for images
with a lower resolution, the intrinsic camera matrix $K$ must be scaled with
the following formula:
\begin{equation}
  K_n = k K,
\end{equation}
where $k$ is a scalar value representing the scale-down factor. As the
intrinsic camera matrix is an instance of an affine transformation, the value
at $K_{n3, 3}$ must be set to 1. The resulting intrinsic camera matrix will
work for smaller resolutions matching the aspect ratio of the images used for
calibration, but it has been observed that when the difference in resolution is
too large, distortion is added back into the image. In FIGURE, the original
image is on the left, the middle image is calibrated using images at 900p and
the right image is calibrated using images at 240p. As can be seen, the image
on the right straightens the ruler, while the middle image leaves it curved.

One downside to camera calibration is that any calibrated image has a lower
resolution than the original image. This is a consequence of the calibration
process, as the process will distort a subset of the image, particularly
involving the pixels around the corners of the image. Therefore the calibration
process will remove these pixels from the resulting image. In order to recreate
the image in its original resolution, an interpolator is used. However, the
interpolator will return a blurrier image than the original. In order to
compensate for this, it is recommended to calibrate a camera with high
resolution images and then capture images at that resolution. Then, instead of
using the interpolator, shrink the images down to a resolution that is
necessary for the application.  This results in a more accurate image without
any blurriness. Unfortunately, this process is computationally heavy and it was
decided to only use the images from the interpolator in order to increase the
performance of the pipeline.

Another downside from the camera calibration is that the midpoint of the camera
shifts. An example of this can be seen in FIGURE. By manually
changing $c_x$, the midpoint of the image can be shifted back to its 
original location.

\section{Color Thresholding}

After the camera calibration comes the color thresholding stage of the pipeline.
This stage removes all pixels from the image that are not yellow with a high
saturation and brightness. 

At first, the image is filtered of all pixels without a high red component, as
bright yellow in the red, green and blue (RGB) color space has a high red
component. Afterwards, the image is converted into the hue, saturation and
value (HSV) color space. 

Under the RGB color space, yellow is represented as a combination of the red 
and green channels with the blue channel set to 0. Pure yellow is also defined 
as having both the red and green channels equal to one another, therefore 
allowing only 1 degree of freedom to tune the pipeline.  Having only 1 degree 
of freedom leads to issues with tuning, as this reduces the ability for the 
pipeline to account for disturbances, such as differing lighting conditions or 
reflective surfaces.

Under the HSV color space, the hue channel selects the color, saturation
channel is a measure of the purity of a hue and the value channel corresponds
to the amount of white or black in the color. (MS ANNO) Once the hue is
selected, here yellow, the lightness and saturation channels are then used to
select the specific shade of yellow. Using these 2 channels allows for a more
robust detection of color.

In order to detect the yellow lane, the pipeline will filter out colors outside 
of the yellow hue range, with a small tolerance, and then truncate the lower 
part of the lightness and saturation channels. As a result of this, only 
relatively pure yellow is left in the image.
The values used in the pipeline for yellow is represented by the following 
range,
TABLE.

An example of the output from this stage of the pipeline is FIGURE.

\section{Perspective Transformation}

The third part of the image processing pipeline is the perspective 
transformation. 

Whenever an image is captured with a camera mounted to the vehicle, the lane
line will be trapezoidal as opposed to straight and lane seems to end in a
point at the center of the image. This perspective requires that all
calculations regarding the lane line must compensate for the decreasing width
of the line. Therefore, to remove this requirement, a perspective
transformation is employed. Perspective transformation is the process by which
a subset of an image is sheared and made to fit the entirety of a new image. An
example is in FIGURE. For this project, the shape of the subset of the image is
a trapezoid due to how lines in the image converge into a point far in the
distance. Using this perspective transform, the trapezoidal shape of the lane
line is corrected into one that is straight, shown in FIGURE.

A consequence of this new perspective, is that the resulting image is similar
to a 2-D plane of the track. The perspective transformation simplifies further
image processing as well, as all objects outside of the trapezoid are cropped,
leaving only the track. However, as can be seen in FIGURE, the perspective
transform introduces extra noise into the image. The shearing caused by the
perspective transform causes pixels from the original image to be stretched,
thereby polluting the image with noise. 

Therefore, this is the third stage in the pipeline. As already discussed, in 
the second stage of the pipeline, the threshold stage removes the majority of 
unnecessary information from the image, which reduces the amount of noise 
caused by the perspective transform.

\section{Histogram}

\iffalse

After the perspective transformation stage, a histogram of the pixel density 
is created. During this step, the start point for the sliding window method is
found. 

At every column of the image, the number of white pixels are counted. 
The numbers are then placed into a list. The assumption is then that the 
columns containing the largest numbers contain the lane information. The 
index with the number is then selected as the start point for the sliding 
window method. This pipeline stage reduces computation time by filtering out 
unnecessary parts of the image not containing lane information. A visual 
representation of the histogram can be seen in FIGURE.

\fi

After the perspective transformation stage, a histogram of the pixel density is
created to determine the start point for the sliding window method. The number
of white pixels is counted for each column of the image, and these numbers are
stored in a list. The columns with the highest numbers are assumed to contain
lane information, and the index of the column with the highest number is
selected as the start point for the sliding window method. This step helps to
reduce computation time by filtering out parts of the image that do not contain
lane information. A visual representation of the histogram can be seen in
FIGURE.

\section{Gleitfenstermethode}


In the fifth stage of the pipeline, the heading and offset of the lane are
calculated through the sliding window method.

First, a chosen number of rectangles (windows) are created. The windows are
aligned in a column and equally sized. Their height is chosen so that the
column spans the entire height of the image, while their width is chosen to be
a factor of the image width. The number of windows is chosen so that the column
entirely or almost entirely  contains the white pixels representing the lane,
as can be seen in FIGURE. If the number of windows is too high, there is a
chance that the method will falsely determine white pixels deep into the image
as a part of the lane. 

Second, the x-coordinate of the midpoint of the first window is set to the peak
of the histogram from the previous stage. Then, the number of white pixels are
then counted inside the window. If the number is above a chosen threshold, the
pixels are added to an array and the mean of the x-coordinates of the contained
pixels is calculated. The x-coordinate of the next window is set to this
calculated mean while being placed on top of the first window. This process is
then repeated for all remaining windows. When no pixels are contained in a
window, the window is ignored and the following window is placed on top of it.
In the image coordinate system, the top left corner of the image is $(0, 0)$,
with the positive x-axis increasing to the right, while the positive y-axis
increases moving down the image. Therefore, the bottom edge of the image would
be any coordinate with a y component equal to the height of the image. Seen
from the engineer's perspective, the windows would be stacked from lowest to
highest, however in the image coordinate space it is inverted. An example can
be seen in FIGURE.

The pixels not located within each window are then filtered out of the image.
The image before and after the filtering process can be seen in FIGURE. Using
the the least squares method, a polynomial is approximated through remaining
pixels.

\section{Berechnung von Ausrichtung und Abstand}
In the final stage of the pipeline, the heading and offset from the lane line
are calculated. 

From the fitted polynomial calculated in the previous stage, an analytical
heading is found at a chosen point along the path with the following equation,
\begin{equation}
  \theta = \arctan(f^\prime(y)).
\end{equation}
The inverse tangent of the derivative of
the polynomial returns the heading at a chosen point. For the Stanley
controller, only the difference between the path heading and vehicle heading
is needed as there is no global frame for the vehicle, the heading
of the vehicle is chosen to be zero degrees at all times. PICTURE WITH VISUAL
REPRSENTATION 

The classic Stanley controller, as described in chapter 2, uses the heading
calculated from the nearest path point. However, as a side effect of the
polynomial fitting, the heading calculated at the bottom of the image is
incorrect. As can be seen in FIGURE, the sliding window method can on average
not detect the lane line close to the bottom of the frame. Due to this, the
fitted polynomial incorrectly approximates the heading. Therefore, the heading
is calculated at a point located within the detected lane line instead.
Moreover, this adds a degree of freedom to the controller. The consequences of
this are discussed in chapter 4.


The offset from the lane line is calculated from the fitted polynomial with
the following function: $$e_{fa} = (\frac{w}{2} - f(h))\cdot x_{mpp},$$ where
$w$ is the width of the image, $f(h)$ is the output of the fitted polynomial
at the bottom of the image, $x_{mpp}$ is a scaling constant to translate
pixels into meters and $e_{fa}$ is the offset from the vehicle to the lane.
All together, the difference of the x-component of the midpoint and the
x-component of the polynomial point located on the bottom edge of the image is
translated into meters.

\section{Ausrei{\ss}er}

\iffalse

A side effect of the sliding window method is a phenomenom termed "outliers".
Outliers are any frame where the lane line is incorrectely determined. In
FIGURE, a sequence of three frames with an outlier are observed with the left
frame being the start. In the first frame, the lane line is correctly
determined. In the second frame, the lane line is incorrectly determined. In
the last frame, the lane line is once again correctly determined. The incorrect
selection of HSV values is the largest contributor to the occurence of
outliers. When the HSV values are not restrictive enough, colors besides yellow
are not filtered out of the image. Which leads to incorrect determination of
the lane line.

Outliers are most common on the curves of the track, due a disadvantage of the
pipeline implementation. As discussed previously, the first window of the
sliding window method is selected at the x-position of the peak of the pixel
histogram. Along the straight part of the track, the lane line is the densest
object in the image. Therefore the peak of the histogram will be along the lane
line. Along the curves, the lane line will be spread across the x-axis leading
to a reduced peak in the histogram. A visual representation can be seen in
FIGURE. A combination of the two previous factors led to the outlier seen in
FIGURE.

\fi

The sliding window method used in lane detection algorithms may result in a
phenomenon known as "outliers". These occur when the algorithm incorrectly
determines the lane line in a given frame. FIGURE shows a sequence of three
frames, with the leftmost frame being the starting point. The first frame
accurately detects the lane line, but in the second frame, an outlier occurs
where the lane line is incorrectly determined. In the final frame, the lane
line is once again correctly identified.

One of the primary causes of outliers is the incorrect selection of HSV values.
When the HSV values used in the algorithm are not restrictive enough, colors
besides yellow may not be filtered out, leading to inaccurate determination of
the lane line.

Outliers are particularly prevalent on curved sections of a track due to a
limitation of the pipeline implementation. As explained earlier, the first
window of the sliding window method is placed at the x-position of the peak of
the pixel histogram. Along the straight portions of the track, the lane line is
the most prominent object in the image, resulting in a peak at the lane line
position in the histogram. However, along curves, the lane line is distributed
across the x-axis, leading to a weaker peak in the histogram. This can be seen
visually in FIGURE. The outlier observed in FIGURE is a result of both
these factors combined.

\section{Pipeline-Optimierungen}

One of the obstacles encountered during the creation of the image processing
pipeline, is that the image would be processed too slowly. The initial
implementation of the pipeline ran at approximately 15 Hz, which was decided to
be close to the lower bound of our chosen tolerance for the processing
frequency. In order to improve the processing speed of the pipeline to an
acceptable level, only 1 optimization was needed. While further optimizations
are possible, they were considered to be out of the scope of the assignment and
are therefore not discussed here.

The Python program cProfiler was used in order to tabulate the function calls
of the pipeline, as well as the runtime of each function call. As the pipeline
is a deterministic program, an simple runtime improvement is to cache the
output of expensive function calls into memory. Therefore during all subsequent
function calls, the cached result is returned instead of running the
calculation again. As an example, the perspective transformation matrices are
an expensive calculation, which when cached led to a speed improvement of the
pipeline.

In order to prove the speed improvement of the pipeline, an experiment was
implemented. First, the pipeline is run through once and the runtime ignored as
the speed improvement is only relevant to subsequent runs of the pipeline.
Then, on the second run of the pipeline, the runtime is measured for both
variants, with and without caching the expensive function calls from the first
run. The experiment is then run 100 times and the result tabulated. The
arithmetic mean of the runtimes for both variants are then compared to one
another to measure the speed improvement. The values are in TABLE, showing that
by caching the expensive function calls, the pipeline processing speed improved
by VALUE%.

\chapter{Experiment}
\section{Hardware Setup}

The CoRoLa car platform is composed of a Raspberry Pi, a fisheye lens camera, a
DC motor and a motor controller to control the vehicle speed and a servo motor
to control the steering angle of the vehicle. The Raspberry Pi sends PWM
signals to the motor controller and the servo controller in order to control
the vehicle. Using Robot Operating System 2 (ros2), the Raspberry Pi is
connected over the network to a central computer. The Stanley controller runs
on the central computer, which processes the data from the camera and sends the
output of the Stanley controller to the vehicle.

\section{Experiment Setup}

In order to compare the Stanley controller and the sliding window method with
the PID controller, 4 test criteria are chosen: maximum acceptable velocity and
maximum offset angles, as well as the root mean square values of the vehicle
offset and controller outputs.

\subsection{H"ochstgeschwindigkeit}

In order to measure the maximum acceptable velocity, vehicle drives around the
track at a given forward velocity. If the behavior of the vehicle is seen as
"acceptable", then the vehicle is stopped and the velocity is increased. This
process repeats until the behavior of the vehicle is no longer "acceptable".
"Acceptable" behavior of the vehicle is defined empirically under the following
two criteria: ability to follow the lane line and an absence of observed
oscillations.

\subsection{Maximal m"oglicher Fehlerwinkel}

The maximum offset angles are defined as the maximum angles at which the
vehicle is able to find the path again, on the left and right of the lane line
respectively. In order to measure this, the vehicle is placed collinear with
the lane line with the motor controller disabled. The vehicle is then turned
clockwise, with the output of the respective controller displayed in realtime.
The vehicle is turned until the output of the controller becomes either chaotic
or the output is consistently zero. The experiment is then executed for the
Stanley Controller and PID Controller. The occurence of chaotic output is
nondeterministic, however empirically it is when the vehicle cannot detect the
lane line reliably. An output of zero also means that the vehicle cannot detect
the lane line at all.

\subsection{Abstand von der Linie}

The measurement of vehicle offset is conducted through the following two
experiments. First, the vehicle starts driving around the track with a selected
forward velocity. Then using an overhead camera, video of the vehicle driving
around the curves is recorded from a top down view. The vehicle is recorded at
differing forward velocities. For the first round of recordings, the vehicle is
controlled by the PID controller and for the second, it is controlled by the
Stanley controller. This experiment is then repeated for the chosen velocities
of 1.0, 1.25, 1.5, 1.75 and 2.0 meters per second.

\subsection{Reglerausgang}

In order to measure the controller output of the two controllers, the vehicle
is commanded to drive around the track at least 3 times. During the drive, the
controller output is recorded. After the drive, the data is graphed over time
and a subset of the data is selected. The subset of the data is selected under
the following criteria: periodicity and absence of outliers.

\section{Ergebnisse}

The results of the experiments are list in TABLE. 


\chapter{Conclusion}
\end{document}
